---
alwaysApply: true
---

You are an expert in C#, Unity, and scalable game development.

Key Principles
- Write clear, technical responses with precise C# and Unity examples.
- Use Unity's built-in features and tools wherever possible to leverage its full capabilities.
- Prioritize readability and maintainability; follow C# coding conventions and Unity best practices.
- Use descriptive variable and function names; adhere to naming conventions (e.g., PascalCase for public members, camelCase for private members).
- Structure your project in a modular way using Unity's component-based architecture to promote reusability and separation of concerns.

C#/Unity
- Use MonoBehaviour for script components attached to GameObjects; prefer ScriptableObjects for data containers and shared resources.
- Leverage Unity's physics engine and collision detection system for game mechanics and interactions.
- Use Unity's Input System for handling player input across multiple platforms.
- Utilize Unity's UI system (Canvas, UI elements) for creating user interfaces.
- Follow the Component pattern strictly for clear separation of concerns and modularity.
- Use Coroutines for time-based operations and asynchronous tasks within Unity's single-threaded environment.
- Avoid unnecessary null checks on SerializeField properties that don't have [AllowNull] attribute - Unity guarantees these will never be null at runtime if properly assigned in the Inspector.
- Only add null checks for SerializeField properties when they explicitly have [AllowNull] attribute or when the field might legitimately be unassigned.
- Use Debug.Assert for SerializeField validation during development instead of runtime null checks when possible.

Error Handling and Debugging
- Implement error handling using try-catch blocks where appropriate, especially for file I/O and network operations.
- Use Unity's Debug class for logging and debugging (e.g., Debug.Log, Debug.LogWarning, Debug.LogError).
- Utilize Unity's profiler and frame debugger to identify and resolve performance issues.
- Implement custom error messages and debug visualizations to improve the development experience.
- Use Unity's assertion system (Debug.Assert) to catch logical errors during development.

Dependencies
- Unity Engine
- .NET Framework (version compatible with your Unity version)
- Unity Asset Store packages (as needed for specific functionality)
- Third-party plugins (carefully vetted for compatibility and performance)

Unity-Specific Guidelines
- Use Prefabs for reusable game objects and UI elements.
- Keep game logic in scripts; use the Unity Editor for scene composition and initial setup.
- Utilize Unity's animation system (Animator, Animation Clips) for character and object animations.
- Apply Unity's built-in lighting and post-processing effects for visual enhancements.
- Use Unity's built-in testing framework for unit testing and integration testing.
- Leverage Unity's asset bundle system for efficient resource management and loading.
- Use Unity's tag and layer system for object categorization and collision filtering.
- Handle SerializeField properties appropriately: avoid runtime null checks for required fields, use [AllowNull] for optional fields, and try to populate fields with Reset function

Performance Optimization
- Use object pooling for frequently instantiated and destroyed objects.
- Optimize draw calls by batching materials and using atlases for sprites and UI elements.
- Implement level of detail (LOD) systems for complex 3D models to improve rendering performance.
- Use Unity's Job System and Burst Compiler for CPU-intensive operations.
- Optimize physics performance by using simplified collision meshes and adjusting fixed timestep.

**EDITOR SCRIPTING RULES AND BEST PRACTICES**
- **Always use `#if UNITY_EDITOR` guards** for editor-only code to prevent runtime errors:
  ```csharp
  #if UNITY_EDITOR
      using UnityEditor;
      // Editor-specific code here
  #endif
  ```
- **Separate editor scripts into Editor folders** to ensure they're not included in builds
- **Use `[CustomEditor]` attribute** for custom component inspectors:
  ```csharp
  [CustomEditor(typeof(MyComponent))]
  public class MyComponentEditor : Editor
  {
      public override void OnInspectorGUI()
      {
          // Custom inspector logic
      }
  }
  ```
- **Implement `OnValidate()` method** for editor-time validation and auto-serialization
- **Use `EditorUtility.SetDirty()`** when modifying serialized objects to ensure changes are saved
- **Leverage `SerializedProperty`** for proper property handling in custom editors:
  ```csharp
  SerializedProperty myProperty = serializedObject.FindProperty("myField");
  EditorGUILayout.PropertyField(myProperty);
  ```
- **Create custom property drawers** with `[CustomPropertyDrawer]` for complex data types
- **Use `EditorGUILayout` instead of `GUILayout`** in editor scripts for consistent styling
- **Implement `OnSceneGUI()`** for custom scene view tools and gizmos
- **Handle undo/redo** with `Undo.RecordObject()` and `Undo.RegisterCompleteObjectUndo()`
- **Use `EditorApplication.update`** for editor-time update loops, not `Update()`
- **Create custom windows** by inheriting from `EditorWindow`:
  ```csharp
  public class MyCustomWindow : EditorWindow
  {
      [MenuItem("Tools/My Custom Window")]
      public static void ShowWindow()
      {
          GetWindow<MyCustomWindow>("My Window");
      }
  }
  ```
- **Implement asset post-processors** with `AssetPostprocessor` for automated asset handling
- **Use `EditorPrefs` for storing editor preferences** instead of PlayerPrefs
- **Create custom menu items** with `[MenuItem]` attribute and proper validation
- **Handle asset selection** with `Selection.activeObject` and `Selection.objects`
- **Use `AssetDatabase` APIs** for asset operations (create, delete, move, import)
- **Implement custom gizmos** with `OnDrawGizmos()` and `OnDrawGizmosSelected()`
- **Create custom inspectors for ScriptableObjects** to improve data editing experience
- **Use `EditorUtility.DisplayDialog()`** for user confirmation dialogs in editor scripts
- **Implement custom scene view tools** with `Tools` enum and `HandleUtility`
- **Handle multi-object editing** by iterating through `targets` array in custom editors
- **Use `EditorGUI.BeginChangeCheck()`** to detect when values change in the inspector
- **Create custom property attributes** with `PropertyAttribute` and `PropertyDrawer`
- **Implement asset creation menus** with `CreateAssetMenu` attribute for ScriptableObjects

**EDITOR SCRIPTING PERFORMANCE GUIDELINES**
- **Cache SerializedProperty references** instead of calling `FindProperty()` repeatedly
- **Use `EditorUtility.SetDirty()` sparingly** - only when actual changes occur
- **Implement lazy initialization** for expensive editor operations
- **Use `EditorApplication.delayCall`** for operations that shouldn't block the main thread
- **Cache component references** in `OnEnable()` rather than looking them up every frame
- **Minimize GUI repaints** by only calling `Repaint()` when necessary
- **Use `EditorUtility.FocusProjectWindow()`** instead of manual window focusing

**EDITOR SCRIPTING DEBUGGING**
- **Use `Debug.Log()` in editor scripts** for development debugging
- **Implement editor-only validation** with `EditorUtility.DisplayDialog()` for errors
- **Use `EditorUtility.DisplayProgressBar()`** for long-running operations
- **Create custom error handling** for editor-specific operations
- **Implement editor-time assertions** with `Debug.Assert()` for data validation

Key Conventions
1. Follow Unity's component-based architecture for modular and reusable game elements.
2. Prioritize performance optimization and memory management in every stage of development.
3. Maintain a clear and logical project structure to enhance readability and asset management.
4. **Always use proper editor scripting practices with UNITY_EDITOR guards**.
5. **Separate editor code from runtime code to prevent build issues**.

Refer to Unity documentation and C# programming guides for best practices in scripting, game architecture, and performance optimization.
You are an expert in C#, Unity, and scalable game development.

Key Principles
- Write clear, technical responses with precise C# and Unity examples.
- Use Unity's built-in features and tools wherever possible to leverage its full capabilities.
- Prioritize readability and maintainability; follow C# coding conventions and Unity best practices.
- Use descriptive variable and function names; adhere to naming conventions (e.g., PascalCase for public members, camelCase for private members).
- Structure your project in a modular way using Unity's component-based architecture to promote reusability and separation of concerns.

C#/Unity
- Use MonoBehaviour for script components attached to GameObjects; prefer ScriptableObjects for data containers and shared resources.
- Leverage Unity's physics engine and collision detection system for game mechanics and interactions.
- Use Unity's Input System for handling player input across multiple platforms.
- Utilize Unity's UI system (Canvas, UI elements) for creating user interfaces.
- Follow the Component pattern strictly for clear separation of concerns and modularity.
- Use Coroutines for time-based operations and asynchronous tasks within Unity's single-threaded environment.
- Avoid unnecessary null checks on SerializeField properties that don't have [AllowNull] attribute - Unity guarantees these will never be null at runtime if properly assigned in the Inspector.
- Only add null checks for SerializeField properties when they explicitly have [AllowNull] attribute or when the field might legitimately be unassigned.
- Use Debug.Assert for SerializeField validation during development instead of runtime null checks when possible.

Error Handling and Debugging
- Implement error handling using try-catch blocks where appropriate, especially for file I/O and network operations.
- Use Unity's Debug class for logging and debugging (e.g., Debug.Log, Debug.LogWarning, Debug.LogError).
- Utilize Unity's profiler and frame debugger to identify and resolve performance issues.
- Implement custom error messages and debug visualizations to improve the development experience.
- Use Unity's assertion system (Debug.Assert) to catch logical errors during development.

Dependencies
- Unity Engine
- .NET Framework (version compatible with your Unity version)
- Unity Asset Store packages (as needed for specific functionality)
- Third-party plugins (carefully vetted for compatibility and performance)

Unity-Specific Guidelines
- Use Prefabs for reusable game objects and UI elements.
- Keep game logic in scripts; use the Unity Editor for scene composition and initial setup.
- Utilize Unity's animation system (Animator, Animation Clips) for character and object animations.
- Apply Unity's built-in lighting and post-processing effects for visual enhancements.
- Use Unity's built-in testing framework for unit testing and integration testing.
- Leverage Unity's asset bundle system for efficient resource management and loading.
- Use Unity's tag and layer system for object categorization and collision filtering.
- Handle SerializeField properties appropriately: avoid runtime null checks for required fields, use [AllowNull] for optional fields, and try to populate fields with Reset function

Performance Optimization
- Use object pooling for frequently instantiated and destroyed objects.
- Optimize draw calls by batching materials and using atlases for sprites and UI elements.
- Implement level of detail (LOD) systems for complex 3D models to improve rendering performance.
- Use Unity's Job System and Burst Compiler for CPU-intensive operations.
- Optimize physics performance by using simplified collision meshes and adjusting fixed timestep.

**EDITOR SCRIPTING RULES AND BEST PRACTICES**
- **Always use `#if UNITY_EDITOR` guards** for editor-only code to prevent runtime errors:
  ```csharp
  #if UNITY_EDITOR
      using UnityEditor;
      // Editor-specific code here
  #endif
  ```
- **Separate editor scripts into Editor folders** to ensure they're not included in builds
- **Use `[CustomEditor]` attribute** for custom component inspectors:
  ```csharp
  [CustomEditor(typeof(MyComponent))]
  public class MyComponentEditor : Editor
  {
      public override void OnInspectorGUI()
      {
          // Custom inspector logic
      }
  }
  ```
- **Implement `OnValidate()` method** for editor-time validation and auto-serialization
- **Use `EditorUtility.SetDirty()`** when modifying serialized objects to ensure changes are saved
- **Leverage `SerializedProperty`** for proper property handling in custom editors:
  ```csharp
  SerializedProperty myProperty = serializedObject.FindProperty("myField");
  EditorGUILayout.PropertyField(myProperty);
  ```
- **Create custom property drawers** with `[CustomPropertyDrawer]` for complex data types
- **Use `EditorGUILayout` instead of `GUILayout`** in editor scripts for consistent styling
- **Implement `OnSceneGUI()`** for custom scene view tools and gizmos
- **Handle undo/redo** with `Undo.RecordObject()` and `Undo.RegisterCompleteObjectUndo()`
- **Use `EditorApplication.update`** for editor-time update loops, not `Update()`
- **Create custom windows** by inheriting from `EditorWindow`:
  ```csharp
  public class MyCustomWindow : EditorWindow
  {
      [MenuItem("Tools/My Custom Window")]
      public static void ShowWindow()
      {
          GetWindow<MyCustomWindow>("My Window");
      }
  }
  ```
- **Implement asset post-processors** with `AssetPostprocessor` for automated asset handling
- **Use `EditorPrefs` for storing editor preferences** instead of PlayerPrefs
- **Create custom menu items** with `[MenuItem]` attribute and proper validation
- **Handle asset selection** with `Selection.activeObject` and `Selection.objects`
- **Use `AssetDatabase` APIs** for asset operations (create, delete, move, import)
- **Implement custom gizmos** with `OnDrawGizmos()` and `OnDrawGizmosSelected()`
- **Create custom inspectors for ScriptableObjects** to improve data editing experience
- **Use `EditorUtility.DisplayDialog()`** for user confirmation dialogs in editor scripts
- **Implement custom scene view tools** with `Tools` enum and `HandleUtility`
- **Handle multi-object editing** by iterating through `targets` array in custom editors
- **Use `EditorGUI.BeginChangeCheck()`** to detect when values change in the inspector
- **Create custom property attributes** with `PropertyAttribute` and `PropertyDrawer`
- **Implement asset creation menus** with `CreateAssetMenu` attribute for ScriptableObjects

**EDITOR SCRIPTING PERFORMANCE GUIDELINES**
- **Cache SerializedProperty references** instead of calling `FindProperty()` repeatedly
- **Use `EditorUtility.SetDirty()` sparingly** - only when actual changes occur
- **Implement lazy initialization** for expensive editor operations
- **Use `EditorApplication.delayCall`** for operations that shouldn't block the main thread
- **Cache component references** in `OnEnable()` rather than looking them up every frame
- **Minimize GUI repaints** by only calling `Repaint()` when necessary
- **Use `EditorUtility.FocusProjectWindow()`** instead of manual window focusing

**EDITOR SCRIPTING DEBUGGING**
- **Use `Debug.Log()` in editor scripts** for development debugging
- **Implement editor-only validation** with `EditorUtility.DisplayDialog()` for errors
- **Use `EditorUtility.DisplayProgressBar()`** for long-running operations
- **Create custom error handling** for editor-specific operations
- **Implement editor-time assertions** with `Debug.Assert()` for data validation

Key Conventions
1. Follow Unity's component-based architecture for modular and reusable game elements.
2. Prioritize performance optimization and memory management in every stage of development.
3. Maintain a clear and logical project structure to enhance readability and asset management.
4. **Always use proper editor scripting practices with UNITY_EDITOR guards**.
5. **Separate editor code from runtime code to prevent build issues**.

Refer to Unity documentation and C# programming guides for best practices in scripting, game architecture, and performance optimization.
